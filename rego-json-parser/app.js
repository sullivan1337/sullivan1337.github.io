document.getElementById('generateRego').addEventListener('click', generateRegoPolicy);
document.getElementById('checkApiKey').addEventListener('click', checkApiKey);
document.getElementById('sendFollowUp').addEventListener('click', sendFollowUp);
document.getElementById('useCustomModel').addEventListener('change', toggleModel);
const apiKeyCheckmark = document.getElementById('apiCheckmark');
const apiKeyInput = document.getElementById('apiKey');

let conversationId = null;
let useCustomModel = false;
let generatedRegoPolicy = false;

async function toggleModel() {
    useCustomModel = document.getElementById('useCustomModel').checked;
    const customModelInput = document.getElementById('customModel');
    customModelInput.disabled = !useCustomModel;
}


async function checkApiKey() {
    const apiKey = apiKeyInput.value.trim();

    const headers = {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${apiKey}`
    };
    const url = "https://api.openai.com/v1/completions";
    const data = {
        "prompt": "Test API key",
        "model": "text-davinci-003",
        "max_tokens": 1,
        "n": 1,
        "stop": null,
        "temperature": 0.5
    };

    const response = await fetch(url, {
        method: "POST",
        headers: headers,
        body: JSON.stringify(data)
    });

    const checkmark = document.getElementById('apiCheckmark');
    const crossmark = document.getElementById('apiCrossmark');
    if (response.ok) {
        checkmark.style.visibility = "visible";
        crossmark.style.visibility = "hidden";
        alert('API key is valid!');
    } else {
        checkmark.style.visibility = "hidden";
        crossmark.style.visibility = "visible";
        crossmark.style.color = "red";
        alert('Invalid API key. Please enter a valid key and try again.');
    }
}

async function generateRegoPolicy() {
    const userQuery = document.getElementById('userQuery').value;
    const jsonInput = document.getElementById('jsonInput').value.trim();
    const regoOutput = document.getElementById('regoOutput');
    const copyButton = document.getElementById('copyButton');
    const apiKey = apiKeyInput.value.trim();

    
    copyButton.addEventListener('click', () => {
        regoOutput.select();
        document.execCommand('copy');
    });

    let parsedJson;
    try {
        parsedJson = JSON.parse(jsonInput);
    } catch (error) {
        alert('Invalid JSON input. Please enter valid JSON and try again.');
        return;
    }
    const formattedJson = JSON.stringify(parsedJson, null, 2);
    document.getElementById('jsonInput').value = formattedJson;

    const trainingPrompt = `Training conversation:
user: [Use OPA's rego policy language

Rego Rule building blocks:
1. Each rule must start with \`package wiz\`
2. \`result\` = mandatory variable that controls the status of the rule
3. \`currentConfiguration := "abc"\` and \`expectedConfiguration := "xyz"\` Output additional context, guidance and information from the Rule which are shown when a Configuration Finding is generated by the Rule. This can use the Rule's variables or plain text.
4. Rather than \`compliant\` and \`noncompliant\` status, make the result return \`pass\`, \`fail\`, or \'skip\' (Resources should be skipped when it wouldn't make sense for the Cloud Configuration Rule to assess them at all. For instance, the built-in Cloud Configuration Rule for default security group should have no rules configured evaluates EC2 Security Groups but skips all non-default groups.)
5. Basic functions relating to time:


time.now_ns() # current time since epoch in nanoseconds
time.parse_duration_ns(duration) # duration valid time units:"s","m","h"("-1h","2h4m")
time.parse_rfc3339_ns(value) # representing the time value in nanoseconds since epoch
For instance, if you wanted to check that secret keys are rotated at least every 90 days:

default result = "pass"

now_ns := time.now_ns()
ninty_days_ns := time.parse_duration_ns("2160h") # 90d in hours

result = "fail" {
    (now_ns - time.parse_rfc3339_ns(input.timeCreated)) > ninty_days_ns
}
6. The following is an example of a good working rego rule: 
\`\`\`
package wiz

default result = "pass"

validFlowLogConfig {
    input.enableFlowLogs
    input.logConfig.aggregationInterval == "INTERVAL_5_SEC"
    input.logConfig.flowSampling == 1
    input.logConfig.metadata == "INCLUDE_ALL_METADATA"
    count(input.logConfig.filterExpr) < 1
}

result = "fail" {
    input.purpose == "PRIVATE"
    not validFlowLogConfig
}

currentConfiguration := "The private subnet's flow logs configuration is missing or invalid"
expectedConfiguration := "Flow logs should be configured"
\`\`\`
7. Reserved names
The following words are reserved and cannot be used for document names:
as
default
else
false
import
package
not
null
some
true
with

8. Operators & logical expressions
Rego offers many built-in logical expressions:


# These are logical expressions
x == y  # x is equal to y ({1,3,1,4} == {4,4,1,3,1} #true)
x != y  # x is not equal to y
x < y   # x is less than y
x <= y  # x is less than or equal to y

# Built-in set functions
s3 := s1 & s2   # s3 is the intersection of s1 and s2
s3 := s1 | s2   # s3 is the union of s1 and s2
s3 := s1 - s2   # s3 is the elements in s1 that are not in s2
One especially useful operator is not, which has several important behaviors:

not turns undefined into true
not turns false into true
not turns everything else into true

# Check if path does not exist
not input.foo.bar

# This is a negation of the return value of the called function
not myfunction

10. 
Logical evaluations
Every line of code in a policy performs a logical evaluation that returns either true or false. If the conditions in a rule never evaluate to true, the result is undefined. As a result, the document that would otherwise be defined by the rule's assignment remains undefined.


# Check if the value of foo equals the value bar, and returns a logical true
# Since the condition is true (foo and bar both equal 1), the assignment is performed
# The assignment overrides the default value of allow, changing it to true
default allow = false
foo := 1
bar := 1
allow = true {
  foo == bar
}

# The string "hello" does not equal the string "world"
# Since the document undefinedDocument was not previously defined, it remains undefined
undefinedDocument { "hello" == "world" }
]

assistant: [Sounds good! I'll follow those guidelines.]
`;

    const prompt = `${trainingPrompt}\nWrite a Rego policy using the user-q and JSON input "user-q":${userQuery}\n"JSON":${formattedJson}\nReturn only the rego rule code starting with "package wiz"`;
    const model = useCustomModel ? document.getElementById('customModel').value.trim() : 'text-davinci-003';
    const response = await fetchChatGPT(prompt, apiKey, model);
    regoOutput.value = response.choices[0].text.trim();
    generatedRegoPolicy = true;
    updateFollowUpInputState();
}

function updateFollowUpInputState() {
    const followUpInput = document.getElementById('followUpInput');
    followUpInput.disabled = !generatedRegoPolicy;
}

updateFollowUpInputState();

async function fetchChatGPT(prompt, apiKey, model, includeConversationHistory = true) {
    const url = "https://api.openai.com/v1/completions";
    const headers = {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${apiKey}`
    };

    const data = {
        "prompt": prompt,
        "model": model,
        "max_tokens": 200,
        "n": 1,
        "stop": null,
        "temperature": 0.5
    };

    const response = await fetch(url, {
        method: "POST",
        headers: headers,
        body: JSON.stringify(data)
    });

    if (response.ok) {
        return await response.json();
    } else {
        throw new Error(`Error: ${response.status}`);
    }
}


async function sendFollowUp() {
    const followUpInput = document.getElementById('followUpInput').value;
    const apiKey = apiKeyInput.value.trim();

    if (!followUpInput) {
        alert('Please enter a follow-up request and try again.');
        return;
    }

    const initialPolicy = document.getElementById('regoOutput').value.trim();
    const prompt = `Initial Rego policy:\n${initialPolicy}\n\nFollow-up request: ${followUpInput}\nPlease provide an updated Rego policy based on the follow-up request.\n`;
    const model = useCustomModel ? document.getElementById('customModel').value.trim() : 'text-davinci-003';
    const response = await fetchChatGPT(prompt, apiKey, model, false); // Pass 'false' to omit conversation history
    const updatedPolicy = response.choices[0].text.trim();
    const regoOutput = document.getElementById('regoOutput');
    regoOutput.value += `\n\────────────────────────────────────────\n\n${updatedPolicy}`; // Append the updated policy below the separator line
}

document.getElementById('generateRego').addEventListener('click', async function() {
    document.getElementById('loading').style.display = 'flex';
    try {
        await generateRegoPolicy();
    } catch (error) {
        console.error(error);
    } finally {
        document.getElementById('loading').style.display = 'none';
    }
});

document.getElementById('sendFollowUp').addEventListener('click', async function() {
    document.getElementById('loading').style.display = 'flex';
    try {
        await sendFollowUp();
    } catch (error) {
        console.error(error);
    } finally {
        document.getElementById('loading').style.display = 'none';
    }
});

document.getElementById('generateRego').addEventListener('click', generateRegoPolicy);
document.getElementById('checkApiKey').addEventListener('click', checkApiKey);
document.getElementById('sendFollowUp').addEventListener('click', sendFollowUp);
const apiKeyCheckmark = document.getElementById('apiCheckmark');
const apiKeyInput = document.getElementById('apiKey');

let conversationId = null;

async function checkApiKey() {
    const apiKey = apiKeyInput.value.trim();

    const headers = {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${apiKey}`
    };
    const url = "https://api.openai.com/v1/completions";
    const data = {
        "prompt": "Test API key",
        "model": "text-davinci-003",
        "max_tokens": 1,
        "n": 1,
        "stop": null,
        "temperature": 0.5
    };

    const response = await fetch(url, {
        method: "POST",
        headers: headers,
        body: JSON.stringify(data)
    });

    const checkmark = document.getElementById('apiCheckmark');
    const crossmark = document.getElementById('apiCrossmark');
    if (response.ok) {
        checkmark.style.visibility = "visible";
        crossmark.style.visibility = "hidden";
        alert('API key is valid!');
    } else {
        checkmark.style.visibility = "hidden";
        crossmark.style.visibility = "visible";
        crossmark.style.color = "red";
        alert('Invalid API key. Please enter a valid key and try again.');
    }
}

async function generateRegoPolicy() {
    const userQuery = document.getElementById('userQuery').value;
    const jsonInput = document.getElementById('jsonInput').value.trim();
    const regoOutput = document.getElementById('regoOutput');
    const copyButton = document.getElementById('copyButton');
    const apiKey = apiKeyInput.value.trim();

    
    copyButton.addEventListener('click', () => {
        regoOutput.select();
        document.execCommand('copy');
    });

    let parsedJson;
    try {
        parsedJson = JSON.parse(jsonInput);
    } catch (error) {
        alert('Invalid JSON input. Please enter valid JSON and try again.');
        return;
    }
    const formattedJson = JSON.stringify(parsedJson, null, 2);
    document.getElementById('jsonInput').value = formattedJson;

    const trainingPrompt = `Training conversation:
user: [Use OPA's rego policy language

Rego Rule building blocks:
1. Each rule must start with \`package wiz\`
2. \`result\` = mandatory variable that controls the status of the rule
3. \`currentConfiguration := "abc"\` and \`expectedConfiguration := "xyz"\` Output additional context, guidance and information from the Rule which are shown when a Configuration Finding is generated by the Rule. This can use the Rule's variables or plain text.
4. Rather than \`compliant\` and \`noncompliant\` status, make the result return \`pass\` or \`fail\`
5. The following is an example of a good working rego rule: 
\`\`\`
package wiz

default result = "pass"

validFlowLogConfig {
    input.enableFlowLogs
    input.logConfig.aggregationInterval == "INTERVAL_5_SEC"
    input.logConfig.flowSampling == 1
    input.logConfig.metadata == "INCLUDE_ALL_METADATA"
    count(input.logConfig.filterExpr) < 1
}

result = "fail" {
    input.purpose == "PRIVATE"
    not validFlowLogConfig
}

currentConfiguration := "The private subnet's flow logs configuration is missing or invalid"
expectedConfiguration := "Flow logs should be configured"
\`\`\`
]

assistant: [Sounds good! I'll follow those guidelines.]
`;

    const prompt = `${trainingPrompt}\nWrite a Rego policy using the user-q and JSON input "user-q":${userQuery}\n"JSON":${formattedJson}\n`;
    const response = await fetchChatGPT(prompt, apiKey);
    regoOutput.value = response.choices[0].text.trim();
}


async function fetchChatGPT(prompt, apiKey, includeConversationHistory = true) {
    const url = "https://api.openai.com/v1/completions";
    const headers = {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${apiKey}`
    };

    const data = {
        "prompt": prompt,
        "model": "text-davinci-003",
        "max_tokens": 200,
        "n": 1,
        "stop": null,
        "temperature": 0.5
    };

    const response = await fetch(url, {
        method: "POST",
        headers: headers,
        body: JSON.stringify(data)
    });

    if (response.ok) {
        return await response.json();
    } else {
        throw new Error(`Error: ${response.status}`);
    }
}


async function sendFollowUp() {
    const followUpInput = document.getElementById('followUpInput').value;
    const apiKey = apiKeyInput.value.trim();

    if (!followUpInput) {
        alert('Please enter a follow-up request and try again.');
        return;
    }

    const prompt = `${followUpInput}\n`;
    const response = await fetchChatGPT(prompt, apiKey, false); // Pass 'false' to omit conversation history
    const regoOutput = document.getElementById('regoOutput');
    regoOutput.value += `\n\n─────────────────────────────────────────────────────────────────────────────\n\n${response.choices[0].text.trim()}`; // Add the line separator
}

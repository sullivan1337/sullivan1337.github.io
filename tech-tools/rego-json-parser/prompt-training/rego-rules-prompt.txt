Use OPA's rego policy language

Rego Rule building blocks:
1. Each rule must start with \`package wiz\`
2. \`result\` = mandatory variable that controls the status of the rule
3. \`currentConfiguration := "abc"\` and \`expectedConfiguration := "xyz"\` Output additional context, guidance and information from the Rule which are shown when a Configuration Finding is generated by the Rule. This can use the Rule's variables or plain text.
4. Rather than \`compliant\` and \`noncompliant\` status, make the result return \`pass\`, \`fail\`, or \'skip\' (Resources should be skipped when it wouldn't make sense for the Cloud Configuration Rule to assess them at all. For instance, the built-in Cloud Configuration Rule for default security group should have no rules configured evaluates EC2 Security Groups but skips all non-default groups.)
5. Basic functions relating to time:


time.now_ns() # current time since epoch in nanoseconds
time.parse_duration_ns(duration) # duration valid time units:"s","m","h"("-1h","2h4m")
time.parse_rfc3339_ns(value) # representing the time value in nanoseconds since epoch
For instance, if you wanted to check that secret keys are rotated at least every 90 days:

default result = "pass"

now_ns := time.now_ns()
ninty_days_ns := time.parse_duration_ns("2160h") # 90d in hours

result = "fail" {
    (now_ns - time.parse_rfc3339_ns(input.timeCreated)) > ninty_days_ns
}
6. The following is an example of a good working rego rule: 
\`\`\`
package wiz

default result = "pass"

validFlowLogConfig {
    input.enableFlowLogs
    input.logConfig.aggregationInterval == "INTERVAL_5_SEC"
    input.logConfig.flowSampling == 1
    input.logConfig.metadata == "INCLUDE_ALL_METADATA"
    count(input.logConfig.filterExpr) < 1
}

result = "fail" {
    input.purpose == "PRIVATE"
    not validFlowLogConfig
}

currentConfiguration := "The private subnet's flow logs configuration is missing or invalid"
expectedConfiguration := "Flow logs should be configured"
\`\`\`
7. Reserved names
The following words are reserved and cannot be used for document names:
as
default
else
false
import
package
not
null
some
true
with

8. Operators & logical expressions
Rego offers many built-in logical expressions:


# These are logical expressions
x == y  # x is equal to y ({1,3,1,4} == {4,4,1,3,1} #true)
x != y  # x is not equal to y
x < y   # x is less than y
x <= y  # x is less than or equal to y

# Built-in set functions
s3 := s1 & s2   # s3 is the intersection of s1 and s2
s3 := s1 | s2   # s3 is the union of s1 and s2
s3 := s1 - s2   # s3 is the elements in s1 that are not in s2
One especially useful operator is not, which has several important behaviors:

not turns undefined into true
not turns false into true
not turns everything else into true

# Check if path does not exist
not input.foo.bar

# This is a negation of the return value of the called function
not myfunction

10. 
Logical evaluations
Every line of code in a policy performs a logical evaluation that returns either true or false. If the conditions in a rule never evaluate to true, the result is undefined. As a result, the document that would otherwise be defined by the rule's assignment remains undefined.


# Check if the value of foo equals the value bar, and returns a logical true
# Since the condition is true (foo and bar both equal 1), the assignment is performed
# The assignment overrides the default value of allow, changing it to true
default allow = false
foo := 1
bar := 1
allow = true {
  foo == bar
}

# The string "hello" does not equal the string "world"
# Since the document undefinedDocument was not previously defined, it remains undefined
undefinedDocument { "hello" == "world" }
